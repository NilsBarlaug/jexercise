/*
 * generated by Xtext
 */
package no.hal.emfs.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import no.hal.emfs.ClasspathEntry;
import no.hal.emfs.DotClasspathFileContentProvider;
import no.hal.emfs.DotProjectFileContentProvider;
import no.hal.emfs.EmfsContainer;
import no.hal.emfs.EmfsFile;
import no.hal.emfs.EmfsPackage;
import no.hal.emfs.EmfsResourcesRef;
import no.hal.emfs.GitContentProvider;
import no.hal.emfs.GitContentRef;
import no.hal.emfs.GitURLContentProvider;
import no.hal.emfs.Property;
import no.hal.emfs.PropertyValueString;
import no.hal.emfs.StringContentProvider;
import no.hal.emfs.URLContentProvider;
import no.hal.emfs.VerbatimStringContents;
import no.hal.emfs.WrappingStringContentProvider;
import no.hal.emfs.XmlAttribute;
import no.hal.emfs.XmlContents;
import no.hal.emfs.XmlPIElement;
import no.hal.emfs.XmlStringContents;
import no.hal.emfs.XmlTag;
import no.hal.emfs.XmlTagElement;
import no.hal.emfs.xtext.services.XemfsGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractXemfsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XemfsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EmfsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EmfsPackage.CLASSPATH_ENTRY:
				sequence_ClasspathEntry(context, (ClasspathEntry) semanticObject); 
				return; 
			case EmfsPackage.DOT_CLASSPATH_FILE_CONTENT_PROVIDER:
				sequence_DotClasspathFileContentProvider(context, (DotClasspathFileContentProvider) semanticObject); 
				return; 
			case EmfsPackage.DOT_PROJECT_FILE_CONTENT_PROVIDER:
				sequence_DotProjectFileContentProvider(context, (DotProjectFileContentProvider) semanticObject); 
				return; 
			case EmfsPackage.EMFS_CONTAINER:
				if (rule == grammarAccess.getEmfsResourceRule()
						|| rule == grammarAccess.getEmfsContainerRule()) {
					sequence_EmfsContainer(context, (EmfsContainer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEmfsRootRule()) {
					sequence_EmfsRoot(context, (EmfsContainer) semanticObject); 
					return; 
				}
				else break;
			case EmfsPackage.EMFS_FILE:
				sequence_EmfsFile(context, (EmfsFile) semanticObject); 
				return; 
			case EmfsPackage.EMFS_RESOURCES_REF:
				sequence_EmfsResourcesRef(context, (EmfsResourcesRef) semanticObject); 
				return; 
			case EmfsPackage.GIT_CONTENT_PROVIDER:
				sequence_GitContentProvider(context, (GitContentProvider) semanticObject); 
				return; 
			case EmfsPackage.GIT_CONTENT_REF:
				sequence_GitContentRef(context, (GitContentRef) semanticObject); 
				return; 
			case EmfsPackage.GIT_URL_CONTENT_PROVIDER:
				sequence_GitURLContentProvider(context, (GitURLContentProvider) semanticObject); 
				return; 
			case EmfsPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case EmfsPackage.PROPERTY_VALUE_STRING:
				sequence_PropertyValueString(context, (PropertyValueString) semanticObject); 
				return; 
			case EmfsPackage.STRING_CONTENT_PROVIDER:
				sequence_StringContentProvider(context, (StringContentProvider) semanticObject); 
				return; 
			case EmfsPackage.URL_CONTENT_PROVIDER:
				sequence_URLContentProvider(context, (URLContentProvider) semanticObject); 
				return; 
			case EmfsPackage.VERBATIM_STRING_CONTENTS:
				sequence_VerbatimStringContents(context, (VerbatimStringContents) semanticObject); 
				return; 
			case EmfsPackage.WRAPPING_STRING_CONTENT_PROVIDER:
				sequence_WrappingStringContentProvider(context, (WrappingStringContentProvider) semanticObject); 
				return; 
			case EmfsPackage.XML_ATTRIBUTE:
				sequence_XmlAttribute(context, (XmlAttribute) semanticObject); 
				return; 
			case EmfsPackage.XML_CONTENTS:
				sequence_XmlContents(context, (XmlContents) semanticObject); 
				return; 
			case EmfsPackage.XML_PI_ELEMENT:
				sequence_XmlPIElement(context, (XmlPIElement) semanticObject); 
				return; 
			case EmfsPackage.XML_STRING_CONTENTS:
				sequence_XmlStringContents(context, (XmlStringContents) semanticObject); 
				return; 
			case EmfsPackage.XML_TAG:
				sequence_XmlTag(context, (XmlTag) semanticObject); 
				return; 
			case EmfsPackage.XML_TAG_ELEMENT:
				sequence_XmlTagElement(context, (XmlTagElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractClasspathEntry returns ClasspathEntry
	 *     ClasspathEntry returns ClasspathEntry
	 *
	 * Constraint:
	 *     (explicitKind=ClasspathEntryKind absolute?='/'? explicitPath=CLASSPATH_ENTRY_PATH (major=VERSION minor=VERSION?)?)
	 */
	protected void sequence_ClasspathEntry(ISerializationContext context, ClasspathEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DotClasspathFileContentProvider returns DotClasspathFileContentProvider
	 *
	 * Constraint:
	 *     entries+=AbstractClasspathEntry+
	 */
	protected void sequence_DotClasspathFileContentProvider(ISerializationContext context, DotClasspathFileContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DotProjectFileContentProvider returns DotProjectFileContentProvider
	 *
	 * Constraint:
	 *     ((keys+=STRING | keys+=FileName)+ (linkedResources+=[EmfsResource|EmfsName] linkedResources+=[EmfsResource|EmfsName]*)*)
	 */
	protected void sequence_DotProjectFileContentProvider(ISerializationContext context, DotProjectFileContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmfsResource returns EmfsContainer
	 *     EmfsContainer returns EmfsContainer
	 *
	 * Constraint:
	 *     (
	 *         name=FolderName 
	 *         tags+=EmfsName* 
	 *         properties+=Property* 
	 *         (contentProvider=GitContentProvider | contentProvider=EmfsResourcesRef)? 
	 *         resources+=EmfsResource*
	 *     )
	 */
	protected void sequence_EmfsContainer(ISerializationContext context, EmfsContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmfsResource returns EmfsFile
	 *     EmfsFile returns EmfsFile
	 *
	 * Constraint:
	 *     (
	 *         name=FileName 
	 *         writeable?='*'? 
	 *         tags+=ID* 
	 *         properties+=Property* 
	 *         (
	 *             contentProvider=URLContentProvider | 
	 *             contentProvider=GitURLContentProvider | 
	 *             contentProvider=StringContentProvider | 
	 *             contentProvider=WrappingStringContentProvider | 
	 *             contentProvider=DotClasspathFileContentProvider | 
	 *             contentProvider=DotProjectFileContentProvider
	 *         )?
	 *     )
	 */
	protected void sequence_EmfsFile(ISerializationContext context, EmfsFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmfsResourcesRef returns EmfsResourcesRef
	 *
	 * Constraint:
	 *     (resources+=[EmfsResource|EmfsName] resources+=[EmfsResource|EmfsName]*)
	 */
	protected void sequence_EmfsResourcesRef(ISerializationContext context, EmfsResourcesRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmfsRoot returns EmfsContainer
	 *
	 * Constraint:
	 *     (name=EmfsName? tags+=ID* properties+=Property* (contentProvider=GitContentProvider | contentProvider=EmfsResourcesRef)? resources+=EmfsResource*)
	 */
	protected void sequence_EmfsRoot(ISerializationContext context, EmfsContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GitContentProvider returns GitContentProvider
	 *
	 * Constraint:
	 *     gitRef=GitContentRef
	 */
	protected void sequence_GitContentProvider(ISerializationContext context, GitContentProvider semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EmfsPackage.Literals.GIT_CONTENT_PROVIDER__GIT_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EmfsPackage.Literals.GIT_CONTENT_PROVIDER__GIT_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGitContentProviderAccess().getGitRefGitContentRefParserRuleCall_0(), semanticObject.getGitRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GitContentRef returns GitContentRef
	 *
	 * Constraint:
	 *     ((((host=URL_HOST_NAME | host=PROPERTY_REF) (owner=ID | owner=PROPERTY_REF)?) | owner=ID | owner=PROPERTY_REF) repo=ID path=URL_PATH?)
	 */
	protected void sequence_GitContentRef(ISerializationContext context, GitContentRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GitURLContentProvider returns GitURLContentProvider
	 *
	 * Constraint:
	 *     gitRef=GitContentRef
	 */
	protected void sequence_GitURLContentProvider(ISerializationContext context, GitURLContentProvider semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EmfsPackage.Literals.GIT_URL_CONTENT_PROVIDER__GIT_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EmfsPackage.Literals.GIT_URL_CONTENT_PROVIDER__GIT_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGitURLContentProviderAccess().getGitRefGitContentRefParserRuleCall_0(), semanticObject.getGitRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractStringContents returns PropertyValueString
	 *     PropertyValueString returns PropertyValueString
	 *
	 * Constraint:
	 *     (writeable?='*'? (propertyName=ID | propertyName=EmfsName) (defaultValue=STRING | defaultValue=EmfsName)?)
	 */
	protected void sequence_PropertyValueString(ISerializationContext context, PropertyValueString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=EmfsName (value=STRING | value=EmfsName))
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringContentProvider returns StringContentProvider
	 *
	 * Constraint:
	 *     stringContents+=AbstractStringContents+
	 */
	protected void sequence_StringContentProvider(ISerializationContext context, StringContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URLContentProvider returns URLContentProvider
	 *
	 * Constraint:
	 *     (urlString=STRING | urlString=URL)
	 */
	protected void sequence_URLContentProvider(ISerializationContext context, URLContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractStringContents returns VerbatimStringContents
	 *     VerbatimStringContents returns VerbatimStringContents
	 *
	 * Constraint:
	 *     (writeable?='*'? tags+=ID* properties+=Property* (stringContent=STRING | stringContent=STRING_CONTENT))
	 */
	protected void sequence_VerbatimStringContents(ISerializationContext context, VerbatimStringContents semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WrappingStringContentProvider returns WrappingStringContentProvider
	 *
	 * Constraint:
	 *     (prefix=AbstractStringContents (contentProvider=URLContentProvider | contentProvider=GitURLContentProvider) suffix=AbstractStringContents)
	 */
	protected void sequence_WrappingStringContentProvider(ISerializationContext context, WrappingStringContentProvider semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmlAttribute returns XmlAttribute
	 *
	 * Constraint:
	 *     (name=ID (value=STRING | value=XmlInt)?)
	 */
	protected void sequence_XmlAttribute(ISerializationContext context, XmlAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmlContents returns XmlContents
	 *
	 * Constraint:
	 *     (element=XmlElement post=XML_TEXT)
	 */
	protected void sequence_XmlContents(ISerializationContext context, XmlContents semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EmfsPackage.Literals.XML_CONTENTS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EmfsPackage.Literals.XML_CONTENTS__ELEMENT));
			if (transientValues.isValueTransient(semanticObject, EmfsPackage.Literals.XML_CONTENTS__POST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EmfsPackage.Literals.XML_CONTENTS__POST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmlContentsAccess().getElementXmlElementParserRuleCall_0_0(), semanticObject.getElement());
		feeder.accept(grammarAccess.getXmlContentsAccess().getPostXML_TEXTTerminalRuleCall_1_0(), semanticObject.getPost());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmlElement returns XmlPIElement
	 *     XmlPIElement returns XmlPIElement
	 *
	 * Constraint:
	 *     (name=ID attributes+=XmlAttribute*)
	 */
	protected void sequence_XmlPIElement(ISerializationContext context, XmlPIElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractStringContents returns XmlStringContents
	 *     XmlStringContents returns XmlStringContents
	 *
	 * Constraint:
	 *     element=XmlElement
	 */
	protected void sequence_XmlStringContents(ISerializationContext context, XmlStringContents semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EmfsPackage.Literals.XML_STRING_CONTENTS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EmfsPackage.Literals.XML_STRING_CONTENTS__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmlStringContentsAccess().getElementXmlElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmlElement returns XmlTagElement
	 *     XmlTagElement returns XmlTagElement
	 *
	 * Constraint:
	 *     (startTag=XmlTag (pre=XML_TEXT contents+=XmlContents* endTag=XmlTagName?)?)
	 */
	protected void sequence_XmlTagElement(ISerializationContext context, XmlTagElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmlTag returns XmlTag
	 *
	 * Constraint:
	 *     (name=XmlTagName attributes+=XmlAttribute*)
	 */
	protected void sequence_XmlTag(ISerializationContext context, XmlTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
